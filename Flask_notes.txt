Using Flask

Route Decorators (@app.route('/'))
  - these are what we type into our browsers use to go to different pages within a website
  - app.route decorators handle all the back-end stuff
    - allow us to write a function that returns the info that will be shown on our website for this specific route
    - the '/' is 'root', or basically the website's homepage


Running the Website from Local Machine Using Environment Variables
  - terminal
  - cd project folder where the python script with the flask app is
  - % export FLASK_APP=<python_script_name.py>
  - % flask run
    - the 'flask run' command starts the local server
    - open the returned ip from terminal in web browser to see the website
      - contains whatever is returned from the function within the '/' route director

Displaying changes in browser in real-time
  - by default, when you make changes to the script, you need to restart the server in terminal for the browser to reflect the changes
    - use control + c to shut down server then re-enter the 'flask run' command
  - we can set Flask to 'debug mode', which will display any saved changes to our file when we refresh the browser.
    - % export FLASK_DEBUG=1
    - % flask run
  - nice! now whenever we save changes to the python script, we can view them in the browser by refreshing the page
    - much better than having to restart the server for every change!

Running our Website straight from Python file (instead of using env variables)
  - this is better if we don't want to mess with command-line variables
  - at the end of the python script, use the following lines of code:

              if __name__ == '__main__':
                  app.run(debug=True)

Adding Routes
  - to add a route, simply add another route decorator with the path to the new page
  - ex: about page
    - @app.route('/about')
    - def about():
    -   return "<h1>About Page</h1>"
  - can add a @app.route('/home') route directly after the app.route('/') so that / and /home go to the same place

Using templates for more complex HTML
  - create templates directory
  - instead of writing the HTML in the python script, we will import them (using Flask's templating module)
  - this allows us to edit all of the HTML in one place without crowding our python script
  - requires us to import render_template from flask
    - so at this point, our import looks like:
      - from flask import Flask, render_template
  - then, in our return statements for our home and about routes:
    - return render_template('home.html')
      - automatically knows to look in the 'templates' dir (must be undercase)

Using Python variables in our html templates:
  - we do this by creating a new argument in the 'return render_template...' line
    - example: assume we have a 'posts' variable containing a list of blog post dictionaries
        return render_template('home.html', posts=posts)
      - we can now reference the name of the argument we created ('posts' in this case) in the html template file.
      - even if the data was saved in variable called 'data', we would still use 'posts' in the html file
        - the .py script would have the arg 'posts=data'
  - now open the home.html template (since that's where we want the posts to be displayed)
    - the templating engine Flask uses is called jinja2
      - it allows us to write code here within our template

HTML template coding with jinja2 (SYNTAX):
  - GENERAL SYNTAX
    - start code blocks using curly brackets and percent signs {% code_here_ %}
    - display variables using double curly brackets (no %): {{ variable.name }}
    - works with list of dicts (at this point each blog post is saved as a dictionary, all of the dictionaries are in a list)
  - LOOPS
    - here's how we display all posts on the home page:
          <body>
            {% for post in posts %}
              <h1>{{ post.title }}</h1>
              <p>By {{ post.author }} on {{ post.date_posted }}</p>
              <p>{{ post.content }}</p>
            {% endfor %}
          </body>
  - IF/ELSE
    - {% if title %}    <-- starts conditional, true if title is given as a parameter in the python script, false otherwise
    - {{ title }}       <-- will display the value assigned to the 'title' param in py script
    - {% else %}
    - default_title_if_none_given
    - {% endif %}

Template Inheritance (blocks)
  - avoids repetition in code
  - requires a separate file to keep all the repeated code, so you can update it all in one place
    - in this project the file is templates/layout.html
  - right now, our home.html and about.html templates contain mostly the same code
    - this will become a pain if we want to change something
  - templates should only show what is unique for that page
    - if I open about.html, I don't want to see the header and title that's present on every other page
  - so, let's create a layout.html file
    - this file will contain everything that is present in all files
    - we will create BLOCKS in the template file in places that can be overridden by the other templates
      - for example, the <body> section is where about.html differs from home.html
      - so within <body> we create a block called 'content' that can be overridden by the other web pages to make them unique
  - looks like this:

      <body>
        {% block content %} {% endblock content %}
      </body>

  - now, we can replace this block in the home.html and about.html files with the relevant content
    - in the home page (where we are displaying blog posts), we put the for loop inside the block
    - first, call {% extends "layout.html" %} as the first line in home.html
      - we're now following the layout in layout.html
    - now time to replace block content in layout.html with blog posts. Here's the syntax:

        {% extends "layout.html" %}
        {% block content %}
            {% for post in posts %}
              <h1>{{ post.title }}</h1>
              <p>By {{ post.author }} on {{ post.date_posted }}</p>
              <p>{{ post.content }}</p>
            {% endfor %}
        {% endblock content %}

Static Folder (for .js and .css files)
  - to reference .css files in our templates, we must store them in a folder called '/static'

YouTube tutorial part 3 (forms & user input) start

Giving users ability to create accounts, login/logout, etc.

Creating forms with WTFORMS
  - not ideal to do this from scratch
  - most popular way to implement forms with Flask is using the WTFORMS module
    - pip install wtf

Creating Forms
  - NOTE: REQUIRES SECRET KEY FOR SECURITY WHEN USING FORMS (will cover later)
  - put new 'forms.py' file in the project's root dir
    - it could go directly into the main app, but it's better to split this up
      - better for code reuse
      - makes project simpler to understand & debug
  - forms.py
    - from flask_wtf import FlaskForm
    - it's a little different than using HTML forms
    - we use python classes to represent our forms, and they will then be converted into HTML forms from our template(s)

Creating Registration Form
  - in forms.py, first create class RegistrationForm that inherits from FlaskForm
    - class RegistrationForm(FlaskForm)
  - within this class is where we give our different fields. Each field has a field type (i.e. StringField, PasswordField)
    - these must be imported @ top as such:
      - from wtforms import StringField, PasswordField
  - Validators
    - passed as a list into the 'validators' arg. of fields
    - need to import them as such:
      - from wtforms.validators import DataRequired, Length, Email, EqualTo
      - what these are:
        - DataRequired: fields with this validator cannot be left empty
        - Length: allows you to set min and/or max length for a certain field (i.e. usernames)
        - Email: ensures valid email
        - EqualTo: validates that the entry in the current field is equal to the value in the referenced field
          - use this for confirm_password fields
          - confirm_password = PasswordField('Confirm PW', validators=[DataRequired(), EqualTo('password')])
            - when 'password' is the name of the original password variable
      - NOTE: validators must have parenthesis in our code (not in import line)
  - Submit button
    - handled with SubmitField (add this to imports)
    - simple: submit = SubmitField('Sign Up')
      - replace 'sign up' with whatever you want the button to say

Creating Login Form
  - we will have our users sign in with their email address (not username)
    - CS preference (and mine) - harder to forget your own email!
  - fields: email/password/remember/submit
    - we've used all of these in our previous form, except for remember
  - Remember field - boolean yes/no for whether or not browser should remember this site

Secret Keys
  - NOTE: MUST USE SECRET KEY WHEN USING FORMS!!
  - before we cover how to use forms in our app, we need to create one of these bad boys.
  - these protect against modifying cookies and cross-site request forgery attacks, and more
  - easy to create. Just go to the top of application file (flask_blog.py)
    - right under app variable, we can set a secret key with:
      - app.config['SECRET_KEY'] = '2c6f7da15b2e9db5e91dd289c8e75a9f'
        - we got this token by opening python session in terminal and typing:
          - import secrets
          - secrets.token_hex(16) <-- 16=num_bytes
            - this command returns a hex token like the one above
  - you will want to make this an environment variable at some point. We'll do this later on in the series

Using Forms in Application
  - to use the forms, we need to import the classes from the 'forms' module we created into our application script (flask_blog.py)
  - now we need to create a registration route and a login route
    - this is done the same way as the other routes, using render_template
    - but since we're using the form, we assign the form we just imported to the 'form' arg of render_template
      - Note we haven't created register.html and login.html yet, but we're about to do that.

Writing Forms into .HTML files
  - each field has it's own div
  - see commented notes in templates/register.html

Getting a Route to Accept Post Requests
  - use the 'methods' param of @app.route in the application (pass a list)
    - @app.route("/register", methods=['GET', 'POST'])

Message Flashing
  - important part of user experience
  - requires 'flash' import (from flask)
  - we'll add an 'account created' alert after a user makes an account
    - 'flash' method takes two params: message text (shown to user) and message category (not shown to user)
  - add the top of content section in layout.html so that on alerts flash by default on any pages (assuming the other .html templates are inheriting from .html)
    - the syntax is in layout.html and can be found in the Flask docs
      - https://flask.palletsprojects.com/en/1.1.x/patterns/flashing/
  -

Handling Redirects
  - this is done in app.py (flask_blog.py in our case)
  - requires the 'redirect' import (from flask)
  - syntax:
      return redirect(url_for('name_of_route_function_to_redirect_to'))
        - ensure redirect location is in quotes
  - we'll add a redirect for the register route to the home page
    - it's confusing to user to fill out a registration form and have the page reload to the same empty form once finished
    - better to redirect them to the /home page and send them an alert ('account created'), which we did in the previous step

Handling Form Errors w/ bootstrap
  - need to edit register.html
  - use an if statement basically saying if there are errors, display them.
  - doing this with bootstrap plugin would be much easier but CS prefers to teach this way so we can make all customization decisions ourselves
  - code doesn't seem very intuitive to me but it works - see register.html

Creating Login page (login.html)
  - copy layout.html content to login.html and modify as follows:
    1. change legend to 'Log In' (from 'Register')
    2. remove the username div/form group (since we're using email, not username, to login)
    3. remove confirm_password div
    4. Change 'Already have an account?' to: 'Don't have an account?'
  - then create a 'Remember Me?' checkbox
    - we'll use bootstrap class "form-check" since it's a checkbox
    - then add the form.remember & label with the 'form-check-input' class
  - create a password reset link
    - with dummy link - can use # in place of actual link

Bootstrap Alert Categories
  - when we flash a message, we can assign it a category (second parameter)
  - the category assigned will determine the way the alert is displayed
    - 'success' - green (ex: 'account created successfully')
    - 'danger' - red (ex: 'invalid password')

Handling Navigation Bar Links (Navbar) w/ url_for
  - the way it's set up right now, our website would break if we changed the name of any of our routes.
    - they are direct links to our routes w/ href
    - instead of '/home' to get to home route, we will use {{ url_for('home') }}
